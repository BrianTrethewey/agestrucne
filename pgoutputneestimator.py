'''
Description
Object manages output from the PGOpNeEstimator object

'''
__filename__ = "pgoutputneestimator.py"
__date__ = "20160502"
__author__ = "Ted Cosart<ted.cosart@umontana.edu>"

from os import path
from genomics.popgen import ne2
class PGOutputNeEstimator( object ):

	OUTPUT_FIELDS = [ "est_ne","95ci_low","95ci_high","overall_rsquared",
					"expected_rsquared","indep_comparisons","harmon_mean_samp_size" ]

	NODAT_FIELDS = [ "Individual", "Locus", "Genotype", "NumberLociMissingData" ]

	OUTPUT_TIAGO_ABBREVS = [ "ne","neci05" , "neci975", "or2", "sr2", "indep", "hmean" ]


	def __init__( self, s_input_file, s_run_output_filename ):
		#we use the name of the input file to check for NoDat file
		#because NeEstimator uses it to name the file
		self.__run_input_file=s_input_file
		self.__run_output_file=s_run_output_filename

		#a list of lists, each a row
		#of values as given by the output_fields.
		#It is set after NeEstimator generates 
		#the output file and user calls def parseOutput
		self.__parsed_output=None
		#Ne Estimator will generate a "*NoDat.txt"
		#file if it encounters incomplete, missing,
		#or all-zero loci values.  See def parseNoDat:
		self.__parsed_nodat_output=None
		self.__validate_filenames()
	#end __init__

	def __validate_filenames( self ):
		ls_existing_files=[]	
		for s_name in [ self.__run_output_file ]:
			if path.exists( s_name ):
				ls_existing_files.append( s_name )
			#end if exists add name
		#end for each filename

		if len( ls_existing_files ) > 0:
			s_msg="In " + type( self ).__name__ \
				+ " object instance. Can't create object because " \
				+ "the following files already exist:\n  " \
				+ "\n  ".join( ls_existing_files) + "."
			raise Exception( s_msg )
		return
	#end __validate_filenames

	def __get_parsed_output_data( self ):

		if not path.exists( self.__run_output_file ):
			raise Exception( "in " + type( self ).__name__ + " instance:" \
					+ "cannot parse output.  File, " \
					+ self.__run_output_file \
					+ ", does not exist." )
		#end if no output file

		o_file=open( self.__run_output_file, 'r' )
		dv_results=ne2.parse( o_file )
		return dv_results
	#end __get_parsed_output_data

	def parseOutput( self ):
		'''
		We assume that for the estimated ne value,
		and its associated CI values, that a value of None in
		the dict returned by ne2.parse def (see above 
		__get_parsed_output_data, reflects
		an "Infinite" value in the origina Ne estimator output
		and so convert it to "Inf,"  as R uses Inf for Infinity
		'''

		MISSING_DATA_ENTRY="NA"
		INFINITE_VALUE="Inf"

		dv_results=self.__get_parsed_output_data()

		self.__parsed_output=[]
		
		for fcases in dv_results.ld:
		    case = fcases[0] 
		    ne = case['EstNe']  if case[ 'EstNe' ] is not None else INFINITE_VALUE
		    or2 = case['OvRSquare'] 
		    sr2 = case['ExpRSquareSample'] 
		    indep = case['IndepComp'] 
		    hmean = case['HMean'] 
		    ne05, ne975 = tuple(case['ParaNe']) 
		    #check the indivicual values of the CI's:
		    ne05=ne05 if ne05 is not None else INFINITE_VALUE 
		    ne975=ne975 if ne975 is not None else INFINITE_VALUE

		    lv_rawvals=[ ne, ne05, ne975, or2, sr2, indep, hmean  ] 
		    lv_vals=[ v_val if v_val is not None else MISSING_DATA_ENTRY for v_val in lv_rawvals ]
		    self.__parsed_output.append(  lv_vals  )
		#end for each case
		    
		return
	#end parseOutput

	def __get_name_nodat_file( self ):
		'''
		we  use the input file name (supplied in __init__
		to check for the nodat file:
		'''

		NODAT_TAG="NoDat.txt"
		s_nodatfile=self.__run_input_file + NODAT_TAG

		if path.exists( s_nodatfile ):
			return s_nodatfile
		else:
			return None
		#end if nodat file exists, else not

		return None

	#end __get_name_nodat_file

	def getNoDatFileName( self ):
		return self.__get_name_nodat_file()
	#end getNoDatFileName

	def parseNoDatFile( self ):
		'''
		This def is provisional, since I have only seen
		a few of the *NoDat.txt files generated by
		NeEstimator (v2). I base the parsing on examples like this:

		Population 1 [OmyLGRA12S_0213]	
		-----------------------------------------------------------
		Individual       Locus         Genotype     Number of Loci
                                          with missing data
		       1            9             0000             4   
		----------------------------------------------------------	
		
	
		
		However thin the ground, this def assumes

		1. multipop results will simply have more table entries
		like the one above.

		2. If a line in the NeEstimator's "*NoDat.txt" file
		starts with the value below in COLHEADSTART, and 
		contains the other column keywords given below
		in COLSINCLUDE, that is must be the header and
		also that the data follows after one mostly line blank
		but for a tag on the last column header

		3. Population name entry for each table is uniqely
		located by the line starting with value below in POPLINESTART
		'''


		POPLINESTART="Population"
		COLHEADSTART="Individual"       
		COLSINCLUDE=[ "Locus", "Genotype", "Number of Loci" ]
		ENDTABLELINESTART="----------------------"	

		s_name=self.__get_name_nodat_file()

		if s_name is None:
			return
		#end return if no nodat file

		self.__parsed_nodat_output=[]

		o_file=open( s_name )

		b_found_header=False
		i_table_lines_count=0
		s_currpop=""
		for s_line in o_file:

			i_num_match=0
			if s_line.startswith( POPLINESTART ):
				#we replace spaces in the pop name:
				s_currpop=s_line.strip().replace( " ", "_" )
			elif s_line.startswith(COLHEADSTART):
				lb_trues=[ s_col in s_line for s_col in COLSINCLUDE ]
				if sum( lb_trues ) == len( COLSINCLUDE ):
					b_found_header=True
					i_table_lines_count=0
				#end if all header names in line
			else:
				#first line after header is more header:
				if b_found_header and i_table_lines_count > 1:
					#if end of table for currpop, 
					#reset flag, line counts
					if s_line.startswith( ENDTABLELINESTART ):
						b_found_header=False
						i_table_lines_count=0
					else:
						i_table_lines_count+=1
						#NoDat.txt files data cols
						#are seperated by multiple space chars,
						#so we use the default split to
						#list only non-space as items:	
						ls_vals=s_line.strip().split() 
						#first col is the pop name
						self.__parsed_nodat_output.append( [ s_currpop ] \
								+ [ s_val for s_val in ls_vals ] )
					#end if end-table line, else data
				#end if header's been found and we're past the non-date line
			#end if pop line else header line, else some other line
		#end for each line in nodat file

		o_file.close()
		return
	#end parseNoDatFile

	def __write_parsed_output_files_tiago_format( self, s_file_ne_vals, s_file_other_vals, b_append=True ):
		'''
		file formats as used by Tiago in his original ne2.py
		one file has just the ne vals and CI's, and another
		has means Rsquareds, etc
		'''
		dv_results=self.__get_parsed_output_data()

		mNes = []
		mOr2s = []
		mSmpr2s = []
		mNesPow = []
		mNesCI = []
		mIndep = []
		mHMean = []

		for fcases in dv_results.ld:
		    case = fcases[0]
		    ne = case['EstNe']
		    or2 = case['OvRSquare']
		    sr2 = case['ExpRSquareSample']
		    indep = case['IndepComp']
		    hmean = case['HMean']
		    ne05, ne975 = tuple(case['ParaNe'])
		    mNes.append(ne)
		    mOr2s.append(or2)
		    mSmpr2s.append(sr2)
		    mNesCI.append((ne975, ne05))
		    mIndep.append(indep)
		    mHMean.append(hmean)
		#end for each item 

		if b_append==True:
			s_open_flag='a'
		else:
			s_open_flag='w'
		#end if append else overwrite

		o_parsed_output_ne_vals= open( s_file_ne_vals, s_open_flag )
		o_parsed_output_ne_vals.write( str(mNes) + "\n"  )
		o_parsed_output_ne_vals.write( str(mNesCI) + "\n" )
		o_parsed_output_ne_vals.close()

		o_parsed_output_other_vals=open( s_file_other_vals, s_open_flag )
		o_parsed_output_other_vals.write(str(mOr2s) + "\n" )
		o_parsed_output_other_vals.write(str(mSmpr2s) + "\n" )
		o_parsed_output_other_vals.write(str(mIndep) + "\n" )
		o_parsed_output_other_vals.write(str(mHMean) + "\n" )
		o_parsed_output_ne_vals.close()

		return
	#end def __write_parsed_output_files_tiago_format

	def __write_parsed_data_lines_as_string( self, llv_parsed_output, s_delim="\t" ):
		s_parsed_output=""
		for lv_output_line in llv_parsed_output:
			s_parsed_output += \
			s_delim.join( [ str(v_entry) for v_entry in lv_output_line ] )
			s_parsed_output += "\n"
		#end for each line of parsed output

		return s_parsed_output
	#end __write_parsed_data_lines_as_string

	def __saveNoDatInfo( self ):
		return
	#end __saveNoDatInfo

	@property
	def parsed_output( self ):
		s_parsed_out=None

		if self.__parsed_output is not None:
			s_parsed_out = self.__write_parsed_data_lines_as_string( \
					self.__parsed_output )
		#end if no parsed output

		return s_parsed_out
	#end parsed_output

	@property
	def parsed_nodat_info( self ):

		s_parsed_out=None

		if self.__parsed_nodat_output is not None:
			s_parsed_out = self.__write_parsed_data_lines_as_string( \
					self.__parsed_nodat_output )
		#end if no parsed output

		return s_parsed_out

	#end parsed_nodat_info

	@property
	def run_output_file( self ):
		return self.__run_output_file
	#end run_output_file

	@run_output_file.setter
	def ouput_file( self, s_name ):
		self.__run_output_file=s_name
		return
	#end run_output_file

	@property
	def run_input_file( self ):
		return self.__run_input_file
	#end run_input_file

	@run_input_file.setter
	def run_input_file( self, s_name ):
		self.__run_input_file=s_name
		return
	#end run_input_file
	
	@property 
	def output_fields( self ):
		return PGOutputNeEstimator.OUTPUT_FIELDS
	#end output_fields


#end class PGOutputNeEstimator

